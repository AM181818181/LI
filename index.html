<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Aberdeen Cat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html, body { margin:0; height:100%; background:#000; }
    .layer { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    /* Splash */
    #splash { background:#131313; color:#eee; font:600 20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; flex-direction:column; gap:10px; cursor:pointer; text-align:center; }
    #splash .btn { padding:.7rem 1.2rem; background:#4c8bf5; border-radius:12px; border:0; color:#fff; cursor:pointer; }
    /* Intro */
    #intro { display:none; background:#000; }
    #intro video { width:100%; height:100%; object-fit:cover; }
    /* Game */
    #game { display:none; background:#111; }
    #wrap { position:relative; width:100vw; max-width:100vw; }
    canvas { background:#222; image-rendering:pixelated; }
    #bubble {
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:22%; max-width:min(80vw,520px);
      padding:.55rem .75rem; border-radius:12px; background:#fff; color:#111;
      font:600 16px/1.15 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow:0 6px 20px rgba(0,0,0,.35); display:none;
    }
    #bubble::after{ content:""; position:absolute; left:50%; transform:translateX(-50%);
      bottom:-8px; border:8px solid transparent; border-top-color:#fff; }
  </style>
</head>
<body>

<!-- Splash -->
<div id="splash" class="layer">
  <div>Aberdeen Cat</div>
  <button class="btn">Click to start â€” press D to move forward</button>
  <div style="opacity:.7;font:14px system-ui">A = left, D = right</div>
</div>

<!-- Intro video -->
<div id="intro" class="layer">
  <video id="introVideo" playsinline preload="auto">
    <source src="intro.mp4" type="video/mp4">
  </video>
</div>

<!-- Game -->
<div id="game" class="layer">
  <div id="wrap">
    <canvas id="cv" width="800" height="450" aria-label="Aberdeen Cat game"></canvas>
    <div id="bubble"></div>
  </div>
</div>

<script>
/* ---------- Filenames ---------- */
const FILES = {
  bg:   'bg.png',
  cat:  'cat.png',
  items:['weed.png','joint.png','bong.png'],
  video:'intro.mp4',
  music:'music.mp3'
};

/* ---------- DOM refs ---------- */
const splash = document.getElementById('splash');
const intro  = document.getElementById('intro');
const video  = document.getElementById('introVideo');
const gameL  = document.getElementById('game');
const wrap   = document.getElementById('wrap');
const canvas = document.getElementById('cv');
const ctx    = canvas.getContext('2d');
const bubble = document.getElementById('bubble');

/* ---------- Audio ---------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let bgmBuffer=null, bgmNode=null;
fetch(FILES.music).then(r=>r.arrayBuffer()).then(b=>audioCtx.decodeAudioData(b)).then(buf=>bgmBuffer=buf);

/* ---------- Splash â†’ Intro ---------- */
function showIntro(){
  if (audioCtx.state === 'suspended') audioCtx.resume();
  splash.style.display = 'none';
  intro.style.display  = 'flex';
  if (bgmBuffer){
    bgmNode = audioCtx.createBufferSource();
    bgmNode.buffer = bgmBuffer;
    bgmNode.loop = true;
    bgmNode.connect(audioCtx.destination);
    bgmNode.start();
  }
  video.play().catch(()=>{});
}
splash.addEventListener('click', showIntro);

/* ---------- Intro â†’ Game ---------- */
video.addEventListener('ended', () => {
  intro.style.display='none';
  gameL.style.display='flex';
  startGame();
});

/* ---------- Responsive canvas ---------- */
function fitCanvas(){
  const W = innerWidth, H = innerHeight;
  const target = Math.min(W, H * (800/450));
  wrap.style.width  = target + 'px';
  wrap.style.height = (target * (450/800)) + 'px';
  canvas.style.width = wrap.style.width;
  canvas.style.height = wrap.style.height;
  ctx.imageSmoothingEnabled = false;
}
addEventListener('resize', fitCanvas);

/* ---------- Game state ---------- */
const state = {
  // camera/world scroll; now controlled by keys
  scrollX:0, scrollSpeed:0, maxSpeed:180, accel:600, // px/s, px/s^2
  // player
  cat:{ x:160, y:308, w:150, h:100, facing:1 }, // facing: 1=right, -1=left
  // items
  items:[],
  totalToSpawn:40, spawned:0, picked:0,
  spawnEveryMsBase:3400, // base cadence
  nextSpawnAt:0,
  img:{ bg:null, cat:null, itemImgs:[] },
  lastT:0,
  gameOverShown:false,
  keys:new Set()
};

/* ---------- Quotes ---------- */
const LINES = [
  "Jackpot! Thatâ€™s some primo meowijuana.",
  "One manâ€™s weedâ€¦ is every catâ€™s weed.",
  "This batch smells like troubleâ€¦ and Iâ€™m into it.",
  "Purr-fection in plant form.",
  "Hydroponics? More like hydropurr-nics.",
  "Snoop Dogg? More like Snoop Cat.",
  "Mine. Mine. Also mine.",
  "Nobodyâ€™s taking this from me. Not even the vacuum.",
  "Iâ€™ll bury this laterâ€¦ maybe in the litter box.",
  "I like my buds big and sticky.",
  "Iâ€™ve been a naughty pussy.",
  "This pussyâ€™s out of control.",
  "This pussyâ€™s lit.",
  "I hope it doesnâ€™t rainâ€¦ or weâ€™ll have a wet pussy on our hands.",
  "Whatâ€™s a catâ€™s favorite film genre? â€˜Cat-nip-and-chillâ€™ movies."
];
let lineIndex = 0;

/* ---------- Input: A/D ---------- */
addEventListener('keydown', e=>{
  if (e.key === 'a' || e.key === 'A') state.keys.add('left');
  if (e.key === 'd' || e.key === 'D') state.keys.add('right');
});
addEventListener('keyup', e=>{
  if (e.key === 'a' || e.key === 'A') state.keys.delete('left');
  if (e.key === 'd' || e.key === 'D') state.keys.delete('right');
});

/* ---------- Helpers ---------- */
function loadImage(src){
  return new Promise((res,rej)=>{
    const i=new Image(); i.onload=()=>res(i); i.onerror=()=>rej(new Error('Image fail '+src)); i.src=src;
  });
}
function showBubble(text){
  bubble.textContent = text;
  bubble.style.display = 'block';
  clearTimeout(showBubble._t);
  showBubble._t = setTimeout(()=> bubble.style.display='none', 2000);
}
function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function spawnItem(now){
  const type = Math.floor(Math.random()*state.img.itemImgs.length);
  const size = 48;
  const y = 340 + Math.floor(Math.random()*8 - 4);
  state.items.push({ x: canvas.width + 40, y, w:size, h:size, type, alive:true });
  state.spawned++;
  // randomized spacing â‰ˆ 2.8sâ€“4.6s
  const nextDelay = 2800 + Math.random()*1800;
  state.nextSpawnAt = now + nextDelay;
}

function drawTiledBG(img, scrollX){
  const scaleY = canvas.height / img.height;
  const drawW = img.width * scaleY;
  let x = - (scrollX % drawW);
  while (x < canvas.width){
    ctx.drawImage(img, x, 0, drawW, canvas.height);
    x += drawW;
  }
}

function drawCatFlippable(img, x, y, w, h, facing){
  if (facing === 1) {
    ctx.drawImage(img, x, y, w, h);
  } else {
    // flip horizontally around cat's left edge
    ctx.save();
    ctx.translate(x + w, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, y, w, h);
    ctx.restore();
  }
}

function draw(){
  drawTiledBG(state.img.bg, state.scrollX);
  for(const it of state.items) if(it.alive){
    ctx.drawImage(state.img.itemImgs[it.type], it.x, it.y, it.w, it.h);
  }
  drawCatFlippable(state.img.cat, state.cat.x, state.cat.y, state.cat.w, state.cat.h, state.cat.facing);

  // UI: score
  ctx.fillStyle='rgba(0,0,0,.5)';
  ctx.fillRect(12,10,220,28);
  ctx.fillStyle='#fff';
  ctx.font='16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillText(`Picked: ${state.picked} / ${state.totalToSpawn}`, 20, 30);

  if(state.picked >= state.totalToSpawn){
    ctx.fillStyle='rgba(0,0,0,.6)';
    ctx.fillRect(0, canvas.height/2-30, canvas.width, 60);
    ctx.fillStyle='#fff';
    ctx.font='bold 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign='center';
    ctx.fillText("Princess is pleased! ðŸŽ‰", canvas.width/2, canvas.height/2+10);
    ctx.textAlign='start';
  }
}

/* ---------- Start game ---------- */
async function startGame(){
  fitCanvas();
  if(!state.img.bg)  state.img.bg  = await loadImage(FILES.bg);
  if(!state.img.cat) state.img.cat = await loadImage(FILES.cat);
  if(!state.img.itemImgs.length){
    for(const p of FILES.items) state.img.itemImgs.push(await loadImage(p));
  }
  state.lastT = performance.now();
  state.nextSpawnAt = state.lastT + 800;
  requestAnimationFrame(loop);
}

/* ---------- Main loop ---------- */
function loop(t){
  const dt = Math.min(50, t - state.lastT); // ms
  state.lastT = t;

  // Determine desired speed from input
  let desired = 0;
  if (state.keys.has('left'))  desired -= state.maxSpeed;
  if (state.keys.has('right')) desired += state.maxSpeed;

  // Flip facing based on input (remember last direction when stopped)
  if (desired < 0) state.cat.facing = -1;
  else if (desired > 0) state.cat.facing = 1;

  // Accelerate toward desired speed
  if (state.picked < state.totalToSpawn) {
    const delta = desired - state.scrollSpeed;
    const step = Math.sign(delta) * state.accel * (dt/1000);
    if (Math.abs(step) > Math.abs(delta)) state.scrollSpeed = desired; else state.scrollSpeed += step;
  } else {
    // after all picked, slow to zero
    const slow = 200 * (dt/1000);
    if (Math.abs(state.scrollSpeed) <= slow) state.scrollSpeed = 0;
    else state.scrollSpeed += -Math.sign(state.scrollSpeed) * slow;
  }

  // Apply scroll to world (background & items)
  const dx = (state.scrollSpeed * dt) / 1000;
  state.scrollX += dx;
  for(const it of state.items) it.x -= dx;

  // Spawning cadence until total reached
  if(state.spawned < state.totalToSpawn && t >= state.nextSpawnAt){
    spawnItem(t);
  }

  // Collisions
  for(const it of state.items) if(it.alive && aabb(state.cat, it)){
    it.alive = false;
    state.picked++;

    const msg = LINES[lineIndex % LINES.length];
    lineIndex++;
    showBubble(msg);

    if(state.picked >= state.totalToSpawn && !state.gameOverShown){
      setTimeout(()=>{
        bubble.textContent = "mitsy is too stoned to continue";
        bubble.style.display = 'block';
      }, 250);
      state.gameOverShown = true;
    }
  }

  // purge offscreen items
  state.items = state.items.filter(it => it.alive || it.x > -it.w - 50);

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  draw();

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
