<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Aberdeen Cat</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    html, body { margin:0; height:100%; background:#000; }
    .layer { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; }
    /* Splash */
    #splash { background:#131313; color:#eee; font:600 20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; flex-direction:column; gap:10px; cursor:pointer; text-align:center; }
    #splash .btn { padding:.7rem 1.2rem; background:#4c8bf5; border-radius:12px; border:0; color:#fff; cursor:pointer; }
    /* Intro */
    #intro { display:none; background:#000; }
    #intro video { width:100%; height:100%; object-fit:cover; }
    /* Game */
    #game { display:none; background:#111; }
    #wrap { position:relative; width:100vw; max-width:100vw; }
    canvas { background:#222; image-rendering:pixelated; }
    #bubble {
      position:absolute; left:50%; transform:translateX(-50%);
      bottom:22%; max-width:min(80vw,520px);
      padding:.55rem .75rem; border-radius:12px; background:#fff; color:#111;
      font:600 16px/1.15 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow:0 6px 20px rgba(0,0,0,.35); display:none;
    }
    #bubble::after{ content:""; position:absolute; left:50%; transform:translateX(-50%);
      bottom:-8px; border:8px solid transparent; border-top-color:#fff; }
  </style>
</head>
<body>

<!-- Splash -->
<div id="splash" class="layer">
  <div>Aberdeen Cat</div>
  <button class="btn">Click to Start</button>
  <div style="opacity:.7;font:14px system-ui">Simple splash â€” click anywhere</div>
</div>

<!-- Intro video -->
<div id="intro" class="layer">
  <video id="introVideo" playsinline preload="auto">
    <source src="intro.mp4" type="video/mp4">
  </video>
</div>

<!-- Game -->
<div id="game" class="layer">
  <div id="wrap">
    <canvas id="cv" width="800" height="450" aria-label="Aberdeen Cat game"></canvas>
    <div id="bubble"></div>
  </div>
</div>

<script>
/* ---------- Filenames (as you provided) ---------- */
const FILES = {
  bg:   'bg.png',
  cat:  'cat.png',
  items:['weed.png','joint.png','bong.png'],
  video:'intro.mp4',
  music:'music.mp3'
};

/* ---------- DOM refs ---------- */
const splash = document.getElementById('splash');
const intro  = document.getElementById('intro');
const video  = document.getElementById('introVideo');
const gameL  = document.getElementById('game');
const wrap   = document.getElementById('wrap');
const canvas = document.getElementById('cv');
const ctx    = canvas.getContext('2d');
const bubble = document.getElementById('bubble');

/* ---------- Audio ---------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let bgmBuffer=null, bgmNode=null;
fetch(FILES.music).then(r=>r.arrayBuffer()).then(b=>audioCtx.decodeAudioData(b)).then(buf=>bgmBuffer=buf);

/* ---------- Splash â†’ Intro ---------- */
function showIntro(){
  if (audioCtx.state === 'suspended') audioCtx.resume();
  splash.style.display = 'none';
  intro.style.display  = 'flex';
  // Start music loop if decoded
  if (bgmBuffer){
    bgmNode = audioCtx.createBufferSource();
    bgmNode.buffer = bgmBuffer;
    bgmNode.loop = true;
    bgmNode.connect(audioCtx.destination);
    bgmNode.start();
  }
  video.play().catch(()=>{}); // if autoplay blocks, user can tap video
}
splash.addEventListener('click', showIntro);

/* ---------- Intro â†’ Game ---------- */
video.addEventListener('ended', () => {
  intro.style.display='none';
  gameL.style.display='flex';
  startGame();
});

/* ---------- Responsive canvas (keep aspect 16:9) ---------- */
function fitCanvas(){
  const W = innerWidth, H = innerHeight;
  const target = Math.min(W, H * (800/450));
  wrap.style.width  = target + 'px';
  wrap.style.height = (target * (450/800)) + 'px';
  canvas.style.width = wrap.style.width;
  canvas.style.height = wrap.style.height;
  ctx.imageSmoothingEnabled = false;
}
addEventListener('resize', fitCanvas);

/* ---------- Game state ---------- */
const state = {
  scrollX:0, scrollSpeed:120,    // px/s
  cat:{ x:160, y:308, w:150, h:100 }, // adjust if your cat.png needs it
  items:[],
  totalToSpawn:40, spawned:0, picked:0,
  spawnEveryMs:3500, nextSpawnAt:0,
  img:{ bg:null, cat:null, itemImgs:[] },
  lastT:0,
  gameOverShown:false
};

/* ---------- Quotes for pickups (yours) ---------- */
const LINES = [
  "Jackpot! Thatâ€™s some primo meowijuana.",
  "One manâ€™s weedâ€¦ is every catâ€™s weed.",
  "This batch smells like troubleâ€¦ and Iâ€™m into it.",
  "Purr-fection in plant form.",
  "Hydroponics? More like hydropurr-nics.",
  "Snoop Dogg? More like Snoop Cat.",
  "Mine. Mine. Also mine.",
  "Nobodyâ€™s taking this from me. Not even the vacuum.",
  "Iâ€™ll bury this laterâ€¦ maybe in the litter box.",
  "I like my buds big and sticky.",
  "Iâ€™ve been a naughty pussy.",
  "This pussyâ€™s out of control.",
  "This pussyâ€™s lit.",
  "I hope it doesnâ€™t rainâ€¦ or weâ€™ll have a wet pussy on our hands.",
  "Whatâ€™s a catâ€™s favorite film genre? â€˜Cat-nip-and-chillâ€™ movies."
];
let lineIndex = 0;

/* ---------- Helpers ---------- */
function loadImage(src){
  return new Promise((res,rej)=>{
    const i=new Image();
    i.onload=()=>res(i);
    i.onerror=()=>rej(new Error('Image fail '+src));
    i.src=src;
  });
}

function showBubble(text){
  bubble.textContent = text;
  bubble.style.display = 'block';
  clearTimeout(showBubble._t);
  showBubble._t = setTimeout(()=> bubble.style.display='none', 2000);
}

function aabb(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }

function spawnItem(){
  const type = Math.floor(Math.random()*state.img.itemImgs.length);
  const size = 48; // keep items consistent
  const y = 340 + Math.floor(Math.random()*8 - 4);
  state.items.push({ x: canvas.width + 40, y, w:size, h:size, type, alive:true });
  state.spawned++;
}

function drawTiledBG(img, scrollX){
  const scaleY = canvas.height / img.height;
  const drawW = img.width * scaleY;    // scale width to match height
  let x = - (scrollX % drawW);
  while (x < canvas.width){
    ctx.drawImage(img, x, 0, drawW, canvas.height);
    x += drawW;
  }
}

function draw(){
  drawTiledBG(state.img.bg, state.scrollX);

  // Items
  for(const it of state.items) if(it.alive){
    ctx.drawImage(state.img.itemImgs[it.type], it.x, it.y, it.w, it.h);
  }

  // Cat (slides)
  ctx.drawImage(state.img.cat, state.cat.x, state.cat.y, state.cat.w, state.cat.h);

  // UI: score
  ctx.fillStyle='rgba(0,0,0,.5)';
  ctx.fillRect(12,10,220,28);
  ctx.fillStyle='#fff';
  ctx.font='16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
  ctx.fillText(`Picked: ${state.picked} / ${state.totalToSpawn}`, 20, 30);

  // End banner
  if(state.picked >= state.totalToSpawn){
    ctx.fillStyle='rgba(0,0,0,.6)';
    ctx.fillRect(0, canvas.height/2-30, canvas.width, 60);
    ctx.fillStyle='#fff';
    ctx.font='bold 28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    ctx.textAlign='center';
    ctx.fillText("Princess is pleased! ðŸŽ‰", canvas.width/2, canvas.height/2+10);
    ctx.textAlign='start';
  }
}

/* ---------- Start game ---------- */
async function startGame(){
  fitCanvas();

  if(!state.img.bg)  state.img.bg  = await loadImage(FILES.bg);
  if(!state.img.cat) state.img.cat = await loadImage(FILES.cat);
  if(!state.img.itemImgs.length){
    for(const p of FILES.items) state.img.itemImgs.push(await loadImage(p));
  }

  state.lastT = performance.now();
  state.nextSpawnAt = state.lastT + 800; // first spawn shortly after start
  requestAnimationFrame(loop);
}

/* ---------- Main loop ---------- */
function loop(t){
  const dt = Math.min(50, t - state.lastT); // clamp to avoid big jumps
  state.lastT = t;

  // Scroll world (background + items)
  const dx = (state.scrollSpeed * dt) / 1000;
  state.scrollX += dx;
  for(const it of state.items) it.x -= dx;

  // Spawn cadence (~ every 3â€“4 seconds) until total reached
  if(state.spawned < state.totalToSpawn && t >= state.nextSpawnAt){
    spawnItem();
    const jitter = 800 * (Math.random() - 0.5);
    state.nextSpawnAt = t + state.spawnEveryMs + jitter;
  }

  // Collisions (when an item reaches the cat)
  for(const it of state.items) if(it.alive && aabb(state.cat, it)){
    it.alive = false;
    state.picked++;

    // Show next quote
    const msg = LINES[lineIndex % LINES.length];
    lineIndex++;
    showBubble(msg);

    // If that was the last nug, show your end line and stop showing quotes after
    if(state.picked >= state.totalToSpawn && !state.gameOverShown){
      setTimeout(()=>{
        bubble.textContent = "mitsy is too stoned to continue";
        bubble.style.display = 'block';
      }, 250); // slight delay so it feels like a final beat
      state.gameOverShown = true;
    }
  }

  // Slow to a stop after finishing
  if(state.picked >= state.totalToSpawn){
    state.scrollSpeed = Math.max(0, state.scrollSpeed - 80 * (dt/1000));
  }

  // purge offscreen items
  state.items = state.items.filter(it => it.alive || it.x > -it.w - 50);

  // draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  draw();

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
